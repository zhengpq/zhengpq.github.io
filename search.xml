<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[????]]></title>
    <url>%2F2018%2F04%2F24%2FdesignParten%2F</url>
    <content type="text"><![CDATA[1 ????????????????????????????????????????? 2 ??????????2.1 ??????????????????????????????????????????????????????????????????????? 1234567891011function award(level, salary) &#123; if (level === &apos;S&apos;) &#123; return salary * 4; &#125; if (level === &apos;A&apos;) &#123; return salary * 3; &#125; if (level === &apos;B&apos;) &#123; return salary * 2; &#125;&#125; ????????????????????? ????????????????if?????????????????????????? ????????????????????????? ??????????????????????????????????????????????????????????? 2.2 ???????? ???????????????????????? ???????????????????????????????????????????????????? ?????????????????????????????????????????????????????? ??????? 12345678910111213141516171819//?????function strategy(number) &#123; return function (salary) &#123; return number * salary; &#125;;&#125;//?????????????const strategies = &#123; S: strategy(4), A: strategy(3), B: strategy(2),&#125;;const calculate = function (level, salary) &#123; return strategies[level](salary);&#125;;console.log(calculate(&apos;S&apos;, 1000));console.log(calculate(&apos;A&apos;, 1000)); 3 ??????????????????????????????????????????? ???????????????????????? ????????????????????????????? ????????????strategies??????????????????calculate??????????????????? 3.1 ???????????????12345678910111213141516171819202122232425262728293031323334353637383940414243// ???class Performance &#123; constructor() &#123;&#125; // ??S???? performanceS(salary) &#123; return salary * 4; &#125; // ??A???? performanceA(salary) &#123; return salary * 3; &#125; // ??B???? performanceB(salary) &#123; return salary * 2; &#125;&#125;// ???class Bonus &#123; constructor() &#123; this.salary = null; // ???? this.strategy = null; // ??????????? &#125; // ????????? setSalary(salary) &#123; this.salary = salary; &#125; // ????????????? setStrategy(strategy) &#123; this.strategy = strategy; &#125; // ???? getBonus() &#123; console.log(this.strategy(this.salary)); &#125;&#125;// ??????????const performance = new Performance();// ???????const bonus = new Bonus();// ????bonus.setSalary(1000);bonus.setStrategy(performance.performanceS);bonus.getBonus(); ????????????????????????????????????????????????????????????????????????????????????????????JavaScript???????????????????????????? 4 ???????????????????????????????????????????????????????????????????????????????????????????????????????????????????? 1234567891011function award(salary) &#123; if (10000 &lt; salary &lt; 20000) &#123; return salary * 0.2; &#125; if (20000 &lt; salary &lt; 30000) &#123; return salary * 0.3; &#125; if (30000 &lt; salary &lt; 40000) &#123; return salary * 0.4; &#125;&#125; ????????????????????????????????? 1234567891011121314151617181920const sections = &#123; section1: [10000, 20000, 0.2], section2: [20000, 30000, 0.3], section3: [30000, 40000, 0.4],&#125;;function strategy(condition) &#123; return function (salary) &#123; for (const key in condition) &#123; if (condition[key][0] &lt; salary &amp;&amp; condition[key][1] &gt; salary) &#123; console.log(salary * condition[key][2]); &#125; &#125; &#125;;&#125;const calculate = function (salary) &#123; strategy(sections)(salary);&#125;;calculate(15000); ?????????????????????????????????????????????section??????????????????????????]]></content>
      <categories>
        <category>????</category>
      </categories>
      <tags>
        <tag>????</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sort]]></title>
    <url>%2F2018%2F03%2F18%2FSort%2F</url>
    <content type="text"><![CDATA[常见的排序算法创建一个测试数组123456789101112131415161718192021222324252627282930313233343536373839404142434445function TextArray(numElement) &#123; this.dataStore = []; this.pos = 0; this.numElements = numElement; this.gaps= null; for (var i = 0; i &lt; this.numElements; i++) &#123; this.dataStore[i] = i; &#125;&#125;//设置数据TextArray.prototype.setData = function () &#123; for (var i = 0; i &lt; this.numElements; i++) &#123; this.dataStore[i] = Math.floor(Math.random()*(this.numElements+1)); &#125;&#125;;//清空数据TextArray.prototype.clear = function () &#123; for (var i = 0; i &lt; this.dataStore.length; i++) &#123; this.dataStore[i] = 0; &#125;&#125;;//插入数据TextArray.prototype.insert = function (element) &#123; this.dataStore[this.pos++] = element;&#125;;//数据以字符串的形式展示TextArray.prototype.toString = function () &#123; var restr = &apos;&apos;; for (var i = 0; i &lt; this.dataStore.length; i++) &#123; restr += this.dataStore[i].toString()+&apos; &apos;; &#125; return restr;&#125;;var textArray = new TextArray(10);textArray.setData();console.log(textArray.toString()); 冒泡排序123456789101112TextArray.prototype.bubbleSort = function () &#123; var temp; for (var i = 0; i &lt; this.dataStore.length; i++) &#123; for (var j = 0; j &lt;this.dataStore.length-1 ; j++) &#123; if (this.dataStore[j]&gt;this.dataStore[j+1]) &#123; temp = this.dataStore[j]; this.dataStore[j] = this.dataStore[j+1]; this.dataStore[j+1] = temp; &#125; &#125; &#125;&#125;; 选择排序123456789101112TextArray.prototype.selectSort = function () &#123; var temp,current; for (var i = 0; i &lt; this.dataStore.length-1; i++) &#123; for (var j = i+1; j &lt;this.dataStore.length ; j++) &#123; if (this.dataStore[i]&gt;this.dataStore[j]) &#123; temp = this.dataStore[i]; this.dataStore[i] = this.dataStore[j]; this.dataStore[j] = temp; &#125; &#125; &#125;&#125;; 插入排序123456789101112TextArray.prototype.insertSort = function () &#123; var tepm,inner; for (var i = 1; i &lt; this.dataStore.length; i++) &#123; tepm = this.dataStore[i]; inner = i; while (inner&gt;0&amp;&amp;(this.dataStore[inner-1]&gt;=tepm))&#123; this.dataStore[inner] = this.dataStore[inner-1]; --inner; &#125; this.dataStore[inner] = tepm; &#125; &#125;; 希尔排序123456789101112TextArray.prototype.shellSort = function (arr) &#123; this.gaps =arr; for (var g = 0; g &lt; this.gaps.length; g++) &#123; for (var i = 0; i &lt; this.dataStore.length; i++) &#123; var temp = this.dataStore[i]; for (var j = i; j&gt;=this.gaps[g]&amp;&amp;this.dataStore[j-this.gaps[g]]&gt;temp; j-=this.gaps[g]) &#123; this.dataStore[j]=this.dataStore[j-this.gaps[g]]; &#125; this.dataStore[j] = temp; &#125; &#125;&#125;; 快速排序1234567891011121314151617TextArray.prototype.quickSort = function (list) &#123; if (list.length ==0) &#123; return; &#125;else &#123; let lessList=[]; let greaterList=[]; let pivot=list[0]; for (let i = 1; i &lt; list.length; i++) &#123; if (list[i]&gt;pivot) &#123; lessList.push(list[i]); &#125;else &#123; greaterList.push(list[i]); &#125; &#125; &#125; return TextArray.quickSort(lessList).concat(pivot,TextArray.quickSort(greaterList));&#125;;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linkList]]></title>
    <url>%2F2018%2F03%2F17%2FlinkList%2F</url>
    <content type="text"><![CDATA[单向链表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//创建节点function Node(element) &#123; this.element = element; this.next=null;&#125;//单向链表function LinkList() &#123; this.head = new Node(&apos;head&apos;);&#125;//遍历链表，查找目标节点LinkList.prototype.find =function (element) &#123; var currentElement = this.head; while (currentElement.element!=element)&#123; currentElement=currentElement.next; &#125; return currentElement;&#125;;//插入新的元素LinkList.prototype.insert =function (target,element) &#123; var newNode = new Node(element); var currentElement = this.find(target); newNode.next=currentElement.next; currentElement.next=newNode;&#125;;//查找目标节点的前面一个节点LinkList.prototype.findPre=function (element) &#123; var currentElement = this.head; while (currentElemend.nextt!=element&amp;&amp;currentElement.next!=null)&#123; currentElement=currentElement.next; &#125; return currentElement;&#125;;//移除一个节点LinkList.prototype.remove=function (element) &#123; var ElementPre = this.findPre(element); if (ElementPre!=null) &#123; ElementPre.next= ElementPre.next.next; &#125;&#125;;//将链表展示出来LinkList.prototype.display = function () &#123; var currentElement = this.head; while (currentElement!=null)&#123; console.log(currentElement); currentElement=currentElement.next; &#125;&#125;; 双向链表1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//创建新的节点function Node(element) &#123; this.element=element; this.pre=null; this.next=null;&#125;//双向链表function DouLinkList() &#123; this.head=new Node(&apos;head&apos;);&#125;//查找某个节点DouLinkList.prototype.find=function (element) &#123; var currentElement = this.head; while (currentElement.element!==element)&#123; currentElement=currentElement.next; &#125; return currentElement;&#125;;//插入一个新的节点DouLinkList.prototype.insert=function (targt,element) &#123; var newElement=new Node(element); var targetElement=this.find(target); targetElement.next.pre=newElement; newElement.next=targetElement.next; newElement.pre=targetElement; targetElement.next=newElement;&#125;;//移除一个节点DouLinkList.prototype.remove=function (element) &#123; var target = this.find(element); if (target.pre===null) &#123; target.next.pre=target.pre; target.next=null; &#125;else if(target.next===null)&#123; target.pre.next=target.next; target.pre=null; &#125;else &#123; target.pre.next=target.next; target.next.pre=target.pre; target.next=null; target.pre=null; &#125;&#125;;//找出链表的结尾元素DouLinkList.prototype.findLast=function () &#123; var currentElement=this.head; while (currentElement.next!==null)&#123; currentElement=currentElement.next; &#125; return currentElement;&#125;; 循环链表循环链表与其他两个的不同在于循环链表在创建头结点的时候将其next指向自身，形成一个循环 1234function CycleList() &#123; this.head=new Node(&apos;head&apos;); this.head.next=this.head;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[列表]]></title>
    <url>%2F2018%2F03%2F17%2FList%2F</url>
    <content type="text"><![CDATA[列表列表的抽象数据结构 方法和属性 作用 listSize 列表元素的个数 pos 列表的当前位置 clear 清空列表 find 寻找指定的元素 toString 将列表变成字符串展示出来 getElement 返回当前位置的元素 insert 在现有元素后插入一个新的元素 append 在列表末尾插入新的元素 remove 移除列表末尾的元素 front 将列表的当前位置移动到第一个元素 end 将列表的当前位置移动到列表的最后一个 prev 将当前位置前移一位 next 将当前位置后移一位 hasNext 判断后一位 hasPrev 判断前一位 currPos 返回列表当前的位置 moveTo 将列表的当前位置移动到指定的位置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576function List() &#123; this.listSize 0; this.pos = 0; this.dataStore = [];&#125;//清空列表List.prototype.clear = function () &#123; delete this.dataStore; this.dataStore=[]; this.listSize = this.pos=0;&#125;;//在列表末尾添加一个新的元素List.prototype.append = function (element) &#123; this.dataStore.push(element); ++this.listSize;&#125;;//寻找指定的元素List.prototype.find = function (element) &#123; var position=this.dataStore.indexOf(element); return (position!=-1)?position:false;&#125;;//将列表变成字符串展示出来List.prototype.toString = function () &#123; return Array.prototype.join.call(this.dataStore,&apos;/n&apos;);&#125;;//返回当前位置的元素List.prototype.getElement = function () &#123; return this.dataStore[this.pos];&#125;;//在现有元素后插入一个新的元素List.prototype.insert = function (element) &#123; this.dataStore.splice(this.pos+1,0,element);&#125;;//从列表中移除元素List.prototype.remove = function (element) &#123; var position = this.find(element); this.dataStore.splice(position,1);&#125;;//将列表的当前位置移动到第一个元素List.prototype.front = function () &#123; this.pos=0;&#125;;//将列表的当前位置移动到第一个元素List.prototype.end = function () &#123; this.pos=this.dataStore.length-1;&#125;;//将当前位置前移一位List.prototype.prev=function () &#123; --this.pos;&#125;;//将当前位置后移一位List.prototype.next=function () &#123; if (this.pos&lt;this.dataStore.length) &#123; ++this.pos; &#125;&#125;;//将当前位置移动到指定位置List.prototype.moveTo=function (position) &#123; if (position&lt;this.dataStore.length) &#123; this.pos=position; &#125;else &#123; return &apos;the position is over the datastore\&apos;s length&apos;; &#125;&#125;;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>列表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器端的EventLoop和node的EventLoop的区别]]></title>
    <url>%2F2018%2F03%2F15%2FevenLoop%2F</url>
    <content type="text"><![CDATA[最近在学习node，看了一些关于node的eventLoop的文章之后得出自己的一些结论，跟大家分享一下，如果有错误的地方，也希望大家指出，多多指教！ 说到JavaScript的异步，绕不开的就是EventLoop，这是JavaScript实现异步的基础，而浏览器端的EventLoop和node的又有很大的不同，下面，就让我们来探讨一下他们之间的区别。 1浏览器EventLoop1.1浏览器端异步浏览器端的异步主要包含下面几个方面： setTimeout setInterval 事件 Ajax 1.2浏览器端的EventLoop的基本模型 上面的很好的解释了浏览器端的异步是如何实现的，下面先看一个代码片段来理解一下：123456789101112131415161718192021222324(function() &#123; console.log(&apos;this is the start&apos;); setTimeout(function cb() &#123; console.log(&apos;this is a msg from call back&apos;); &#125;); console.log(&apos;this is just a message&apos;); setTimeout(function cb1() &#123; console.log(&apos;this is a msg from call back1&apos;); &#125;, 0); console.log(&apos;this is the end&apos;);&#125;)();//输出结果// &quot;this is the start&quot;// &quot;this is just a message&quot;// &quot;this is the end&quot;// &quot;this is a msg from call back&quot;// &quot;this is a msg from call back1&quot; 我们都知道JavaScript是单线程的，但是这个单线程的意思是执行代码是单线程的，这个单线程就是上图的stack，所有的同步代码都是在这里执行的。而异步操纵只会在同步操作执行完之后才会开始执行。上面这段代码的执行经历下面这些过程： 代码从上往下执行，先打印出“this is a msg from call back ”， 解析到第一个setTimeout，而且这个setTimeout没有给出具体的时间参数，那么此时就会默认时间参数是0（需要注意的是0不代表立即将setTimeout的回调函数加入到事件队列中，而是由一定的最小时间限制的），在经过最小时间限制后，就会将setTimeout的回调函数加入到事件队列中。 另外一个同步操作，打印出“this is just a message” 接下来是另外一个setTimeout的回调函数被加入到事件队列中，最后的同步操作打印出“this is the end”。 stack按照加入callbackQueue的回调函数的顺序从callbackQueue中拿出回调函数执行，首先是打印”this is a msg from call back”，然后是打印”this is a msg from call back1” 这就是浏览器端的EventLoop的整个执行过程，这个过程相对来说还是比较简单易懂的。 2 node的EventLoop2.1 基本模型 我们可以看到，node的EventLoop的模型要比浏览器端的复杂很多，下面让我们来一步步进行讲解。 2.1.1 phase 上图中的每一个矩形代表的是事件队列的每一个阶段（官网上叫做“phase”），他们具体负责的工作为（附上官方文档的解释）： Timers：执行setTimeout()和setInterval()绑定的回调函数 this phase executes callbacks scheduled by setTimeout() and setInterval(). I/O callback：执行除了close callbacks、timers以及setImmediate()绑定的回调函数 executes almost all callbacks with the exception of close callbacks, the ones scheduled by timers, and setImmediate(). idle,prepare：只在内部使用 poll：检索新的I/O 事件，并且这个node在适当的时机在这个地方阻塞（具体应用场景我还想不出来，如果有哪位知道请指教一下） retrieve new I/O events; node will block here when appropriate. check：执行setImmediate()绑定的回调函数 setImmediate() callbacks are invoked here. close callbacks：执行关闭事件绑定的回调函数（注意：上面的执行是指将回调函数推到主线程执行） 每个phase代表不同的时期，eventLoop每次轮询都会从timers开始将EventLoop里面的回调函数推导主线程中执行，直到执行完这个phase里面的回调函数或者是执行的数量达到允许的最大值（在每个循环周期中允许执行的函数数目是有限的）后才会进入到下一个phase，按照这样的顺序直到这个周期结束后再进入下个周期。当然，这里面还有很多细节，待会会详细讨论。 这里就可以看出node的EventLoop和浏览器端的EventLoop的很大的不同：浏览器端没有阶段的区分，只会按照回调函数进入事件队列的顺序进行执行，node则会按照不同类型的回调函数在不同阶段有区别地执行。 2.1.2 timerssetTimeout()和setInterval实际上和浏览器端的作用原理是一样的，在指定的时间后将绑定的回调函数添加到事件队列中，而且，当事件设置为0时，也不是立即就将回调函数添加到事件队列的timers中，下面这段是引用官网的说明： When delay is larger than 2147483647 or less than 1, the delay will be set to 1. 下面看看官网的这个例子： 12345678910111213141516171819202122232425const fs = require(&apos;fs&apos;);function someAsyncOperation(callback) &#123; // Assume this takes 95ms to complete fs.readFile(&apos;/path/to/file&apos;, callback);&#125;const timeoutScheduled = Date.now();setTimeout(() =&gt; &#123; const delay = Date.now() - timeoutScheduled; console.log(`$&#123;delay&#125;ms have passed since I was scheduled`);&#125;, 100);// do someAsyncOperation which takes 95 ms to completesomeAsyncOperation(() =&gt; &#123; const startCallback = Date.now(); // do something that will take 10ms... while (Date.now() - startCallback &lt; 10) &#123; // do nothing &#125;&#125;); 让我们来分析一下上面这段代码的是如何执行的： 代码从上向下解析，遇到第一个异步操作-setTimeout，于是将在100ms后将setTimeout绑定的函数添加到timers中 继续向下解析，执行函数someAsyncOperation，函数someAsyncOperation首先读取文件，这个过程花费了95ms 由于在执行执行同步代码的时候没有回调函数添加到事件队列中，所以在进入poll阶段时事件队列还是空的，此时poll会等待到有新的事件被触发。 在文件读取结束后将其绑定的回调函数添加到事件队列中，poll将回调函数推到主线程里面执行，由于这个函数要执行10ms，在执行到5ms时setTimeout绑定的回调函数会被添加到timers中去 等到fs.read()绑定的函数执行完毕后poll检测到timers中有绑定的函数，而且check和close callback如果有绑定函数，就会进入下个阶段，由于下两个阶段（check和close callback）都没有绑定函数，那么就会重新回到timers，此时timers中有函数就推进主线程中执行，所以，最后输出的结果是延迟了105ms 但是，现在有一个问题，如果fs.read()要执行很长时间，那岂不是导致阻塞了吗？答案是：否； 先看一下官方文章里面的几个句子： Note: Technically, the poll phase controls when timers are executed. When the event loop enters the poll phase, it has an empty queue (fs.readFile() has not completed), so it will wait for the number of ms remaining until the soonest timer’s threshold is reached. Once the poll queue is empty the event loop will check for timers whose time thresholds have been reached. If one or more timers are ready, the event loop will wrap back to the timers phase to execute those timers’ callbacks. 上面第一个句子说明了timers其实是受到poll影响的，后面两句说明了如果fs.read()执行的时间太长，超过了timers设定的时间，EventLoop会将timers绑定的函数推到主线程中执行（下面讲解poll的时候会解释），这样避免了阻塞问题 2.1.3 poll这个阶段的功能是最复杂的。先看一下官方文档的解释： The poll phase has two main functions: Executing scripts for timers whose threshold has elapsed, then Processing events in the poll queue. When the event loop enters the poll phase and there are no timers scheduled, one of two things will happen: If the poll queue is not empty, the event loop will iterate through its queue of callbacks executing them synchronously until either the queue has been exhausted, or the system-dependent hard limit is reached. If the poll queue is empty, one of two more things will happen: If scripts have been scheduled by setImmediate(), the event loop will end the poll phase and continue to the check phase to execute those scheduled scripts. If scripts have not been scheduled by setImmediate(), the event loop will wait for callbacks to be added to the queue, then execute them immediately. Once the poll queue is empty the event loop will check for timers whose time thresholds have been reached. If one or more timers are ready, the event loop will wrap back to the timers phase to execute those timers’ callbacks. 首先，上面的这段话说明了poll具有两个功能： 执行那些时间到达的计时器绑定的函数 处理轮询队列中的事件 也就是说通过setTimeout绑定的回调函数有可能会在两个阶段被推到主线程中执行：timers和poll（下面会给出例子解释），但是timers绑定的函数能够在poll阶段被执行的条件是：计时器计时结束（下面会有例子解释） poll的这个阶段回调函数执行还分多种情况： 当事件队列进入poll阶段，同时没有计时器计时结束时，如果poll不是空的，那么就先执行poll里面的回调函数。如果poll是空的同时没有setimmedaite绑定的回调函数，那么EventLoop会直接停留在poll阶段，直到有新的回调函数被加入到事件队列中。如果有setImmediate绑定的函数，则会进入到下个阶段check。 如果事件队列进入到poll阶段并且poll是空的，且有计时器计时结束，事件队列会回到timers，然后执行timers绑定的函数 还是上面那个例子：12345678910111213141516171819202122232425const fs = require(&apos;fs&apos;);function someAsyncOperation(callback) &#123; // Assume this takes 95ms to complete fs.readFile(&apos;/path/to/file&apos;, callback);&#125;const timeoutScheduled = Date.now();setTimeout(() =&gt; &#123; const delay = Date.now() - timeoutScheduled; console.log(`$&#123;delay&#125;ms have passed since I was scheduled`);&#125;, 100);// do someAsyncOperation which takes 95 ms to completesomeAsyncOperation(() =&gt; &#123; const startCallback = Date.now(); // do something that will take 10ms... while (Date.now() - startCallback &lt; 10) &#123; // do nothing &#125;&#125;); 具体的解释可以看上面 2.2 setTimeout和setImmediate两者在很多方面和相似，但是他们的区别还是很大的，而且setTimeout具有的一个缺点是时间的不确定性。先来看看官方给的例子：12345678910111213141516// timeout_vs_immediate.jssetTimeout(() =&gt; &#123; console.log(&apos;timeout&apos;);&#125;, 0);setImmediate(() =&gt; &#123; console.log(&apos;immediate&apos;);&#125;);//结果$ node timeout_vs_immediate.jsimmediatetimeout$ node timeout_vs_immediate.jsimmediatetimeout 可以看到可能有两种结果，为什么呢？因为虽然setTimeout的时间设置为0，但是实际上系统会将其设置为1，所以如果上面的同步代码解析到setImmediate时时间小于1ms，那么就会先将setImmediate加入到事件队列中，反之，则会是将setTimeout加入到事件队列中。 再来看看下面这个例子：12345678910111213141516171819// timeout_vs_immediate.jsconst fs = require(&apos;fs&apos;);fs.readFile(__filename, () =&gt; &#123; setTimeout(() =&gt; &#123; console.log(&apos;timeout&apos;); &#125;, 0); setImmediate(() =&gt; &#123; console.log(&apos;immediate&apos;); &#125;);&#125;);//$ node timeout_vs_immediate.jsimmediatetimeout$ node timeout_vs_immediate.jsimmediatetimeout 上面这个例子只有一种结果，这是为什么呢？因为首先会进行文件的读取，然后就会将fs.readFile的回调函数加入到事件队列中，文件读取结束后执行回调函数，此时EventLoop还没有到达check这个阶段，文件读取绑定回调函数中分别在timers和check阶段绑定了回调函数，所以EventLoop经过poll阶段后进入check阶段执行setImmediate绑定的函数，然后再绕回timers执行setTimeout绑定的函数，这样就得到上面的结果。 2.3 process.nextTick()和setImmediate()这两个方法的实际用途和他们的名字相反，前者是当前的同步执行结束后直接执行其绑定的函数，而setImmediate是只在check阶段才执行。]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异步]]></title>
    <url>%2F2018%2F03%2F15%2Fasy-md%2F</url>
    <content type="text"><![CDATA[1 同步与异步简单来说，单线程对应就是同步，同步执行中每个动作只能等前面那个执行完后才会执行下一个，这样的话如果出现多个执行动作，就会出现时间先后，有可能中间某个动作占用的时间过于长的话就会造成后面的动作一直等待。但是如果是异步呢，多个人进行组装，每个人负责不同的部分，这样的话每个人完成自己的部分之后就可以u干别的事情，而不用去一直等待，这样的效率显然是更高的。 2 Event Loop讲到JavaScript的异步的话肯定要讲到Event Loop，这是JavaScript异步的精髓。首先介绍一下一个很经典的视频（需要翻墙，国内可能也有，需要读者自己去找一下）：What the heck is the event loop anyway? 这里借用阮一峰老师的博客上面的图片： 上面这张图片展示了js代码的执行过程。最主要的三个部分就是stack、callback queue和WebAPIS 2.1 stackstack可以理解成js函数执行的地方。先看看下面这个例子： 1234567891011function fun1()&#123; console.log(&quot;this is a stack&quot;);&#125;;function fun2()&#123; fun1();&#125;;function fun3()&#123; fun2()&#125;; 上面这段代码的执行顺序是： fun3入栈 fun2入栈 fun1入栈 console.log(&quot;this is a stack&quot;) fun1出栈 fun2出栈 fun3出栈 上面这个例子很好地说明了js代码的执行机制。 而且有点需要注意的是stack里面执行的是同步函数，这一点下面会讲解 2.2 WebAPIWebAPI可以看成是临时存储异步命令的地方。 2.3 callback queuecallback queue一种更加通俗的说法是任务队列，任务队列是各种等待执行的任务，当stack处于清空状态的时候stack就会从任务队列中调用任务进行执行，而且这个过程会一直持续直到任务队列为空 2.4 Event Loop运行过程 首先执行stack里面的函数 如果在stack执行过程中有异步命令产生，就会将其传送到WebAPI中。然后按照顺序将异步命令中的回调函数加入到任务队列中，但是setTimeOut和Ajax以及setInterval会有差异，setTimeOut和setInterval会在指定时间后才将回调函数加入到任务队列中（下面有一个例子会讲到），而Ajax请求则是会在请求完成之后才将回调函数加入带任务队列中。 等到stack中的同步函数执行完毕后stack就会开始执行任务队列中的回调函数直到任务队列为空 重复执行上面这几个操作步骤 下面来看例子：12345678910111213console.log(4);setTimeout(function cb()&#123; console.log(&quot;there&quot;);&#125;,0);function fun1()&#123; console.log(&quot;this&quot;);&#125;fun1();//结果：4thisthere 上面这个例子很好地说明了任务队列里面的回调函数只有在stack里面的同步函数执行完毕之后才会开始执行。因为如果不是等待stack里面的同步函数执行完的话，那么一开始打印出来的应该是“there”而不是“this” 3 实现异步由于目前学习知识有限，我先针对自己学习的知识点讲解两种异步的实现方法 3.1 回调函数模式先看一个最简单的例子：123456789function fun3()&#123; console.log(3);&#125;;function fun2(fun)&#123; setTimeout(fun(),1000)&#125;;fun2(fun3);//3 但是这种模式只适合需要调用少量函数的情况，在某些复杂的情况下可能会出现所谓的“回调地狱”，比如下面这个例子： 123456789fun1(function()&#123; fun2(function()&#123; fun3(function()&#123; fun4(function()&#123; fun5() &#125;) &#125;) &#125;)&#125;) 3.2 Promise先看看Promise的最简单的例子123456789101112131415161718let promise = new Promise(function (resolve,reject) &#123; if (dosomething/*异步操作成功*/) &#123; resolve(); &#125;else &#123; reject(); &#125;&#125;);promise.then(fun1,fun2);//使用promise实现settimeoutlet promise = function (fun1,fun2) &#123; return new Promise(function (fun1,fun2) &#123; setTimeout(fun1,1000); &#125;);&#125;;promise().then(function () &#123; console.log(&apos;YOU&apos;);&#125;); 来看看在Node使用Promise实现文件读取的例子12345678910111213141516171819202122232425//promise实现文件读取const fs = require(&apos;fs&apos;);//使用回调函数实现fs.readFile(&apos;try.html&apos;,(err,data)=&gt;&#123; if (err) &#123; console.log(&apos;something wrong&apos;); &#125; console.log(data);&#125;);//promise化function getFile(url) &#123; return new Promise(function (resolve,reject) &#123; fs.readFile(url,function (err,data) &#123; if (err) &#123; reject(err); &#125;else &#123; resolve(data) &#125; &#125;) &#125;);&#125;getFile(&apos;try.html&apos;).then(function (data) &#123; console.log(data); &#125;).catch((err)=&gt;&#123;throw er Promise的实现异步的关键在于使用Promise封装异步操作，然后再返回一个新的Promise对象，实现链式调用。再来看看Promise是怎么解决多层调用的问题的，比如现在有三个文件要读取，但是只能在前一个文件读取完毕之后又才能进入下一个文件的读取，下面展示回调函数形式和Promise形式实现的区别123456789101112131415161718192021222324//回调函数fun1(function()&#123; fun2(function()&#123; fun3(function()&#123; fun4(function()&#123; fun5() &#125;) &#125;) &#125;)&#125;)//Promisefunction getFile(url) &#123; return new Promise(function (resolve,reject) &#123; fs.readFile(url,function (err,data) &#123; if (err) &#123; reject(err); &#125;else &#123; resolve(data) &#125; &#125;) &#125;);&#125;getFile(&apos;try.html&apos;).then(getFile(&apos;fs.js&apos;)).then(getFile(&apos;hello.txt&apos;)).then(()=&gt;&#123;console.log(&apos;success&apos;);&#125;).catch(()=&gt;&#123; throw err&#125;); 所以，使用Promise的关键点在于将原本的回调变成Promise中的resolve，然后返回一个新的Promise对象。 Promise的有趣之处还在于其提供的Promise.all()和Promise.race两个方法。 Promise.all()将多个Promise实例包装成一个新的Promise实例，接收一个数组作为参数。 只有所有的Promise实例状态变成fullfilled时，all才会变成fulfilled 只要有一个实例的状态时rejected，那么all的状态就是rejected 上面的例子其实也可以使用Promise来进行修改，如下：123456let p1 = getFile(&apos;try.html&apos;);let p2 = getfs(&apos;fs.js&apos;);let p3 = getHello(&apos;hello.txt&apos;);let p = Promise.all([p1,p2,p3]);p.then((data)=&gt;&#123;console.log(data);&#125;).catch((err)=&gt;&#123;throw err&#125;);//返回三个文件的data，存于一个数组中//这种写法的好处是可以几个异步同时进行，节省时间 Promise.race()格式和Promise.all()一样，但是不同的地方在于只要p中的一个promise的状态改变，race的状态发生改变。 3.3 Generator实现异步还是上面那个例子，使用generator+co模块实现的代码如下： 123456789101112131415161718function getFile(url) &#123; fs.readFile(url,function (err,data) &#123; return new Promise(function (resolve,reject) &#123; if (err) &#123; reject(); &#125; resolve(); &#125;); &#125;)&#125;//引入co模块辅助自动执行co(function* ()&#123; var f1 = yield readFile(&apos;fs.js&apos;); var f2 = yield readFile(&apos;try.js&apos;); console.log(f1); console.log(f2);&#125;) 3.4 async/await使用async函数实现上面的异步代码如下：123456async function getfs() &#123; let f1 = await getFile(&apos;try.html&apos;); let f2 = await getFile(&apos;fs.js&apos;); return f1;&#125;getfs().then((f1)=&gt;&#123;console.log(f1);&#125;); 需要注意的有以下几点： asyn函数返回一个Promise对象 返回的Promise对象必须等到内部所有await命令的Promise对象执行完毕后，才会发生状态的改变 await后面必须接一个Promise对象，否则其会被转化为Promise对象 只要有一个await后面的Promise变为reject，那么整个async就会中断执行 一旦遇到await，就会等到await执行完毕后再执行后面的代码。 捕获错误时，最好将await放在try...catch中 123456async function getfs() &#123; let f1=await getFile(&apos;try.html&apos;).catch((error)=&gt;&#123; throw error&#125;); let f2 = await getFile(&apos;fs.js&apos;); return f1;&#125;getfs().then((f1)=&gt;&#123;console.log(f1);&#125;); 对于不存在继发关系的多个异步操作，为节省时间最好同时触发 1let [foo, bar] = await Promise.all([getFoo(), getBar()]);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flex]]></title>
    <url>%2F2018%2F03%2F08%2Fflex%2F</url>
    <content type="text"><![CDATA[因为老是记不住flex的API对应的样式，所以这篇文章主要就是让自己平时用的时候可以快速查阅，节约时间。 flex布局是CSS3中提出的概念，其优点在于能够使用很少的样式实现比较复杂的布局，相比CSS2中的使用display+position+float的实现方式，类似于高铁和绿皮火车之间的差别。 语法块状元素实现flex布局：1div&#123;display:flex;&#125; 行内元素实现flex布局：1div&#123;display:inline-flex;&#125; 基本概念容器flex化之后，其内部解构如下（这里借用一下阮老师的图）： flex item：容器内部的元素main axis：主轴，内部元素默认沿着主轴排列main start：主轴开始的地方main end：主轴结束的地方cross axis：交叉轴cross start：交叉轴开始的地方cross end：交叉轴结束的地方main size：单个内部元素在主轴方向上占据的长度cross size：单个内部元素在交叉轴方向上占据的长度 属性及其值 flex-direction:row | row-reverse | column | column-reverse flex-wrap:nowrap | wrap | wrap-reverse flex-flow:&lt;flex-direction | &lt;flex-wrap&gt; justify-content:flex-start | flex-end | cneter | space-between | space-around align-items: flex-start | flex-end | center | baseline | stretch align-content: flex-start | flex-end | center | space-between | space-around | stretch; flex-direction定义主轴的方向 row：默认，主轴的方向为水平，起点在左端 row-reverse：主轴为水平，起点在右端 column：主轴为竖直方向，起点在顶端 column-reverse：主轴为竖直方向，起点在底端 对flex盒子的内部元素进行width的设置时，实际上相当于是给元素设置了一个max-width，如下面例子：123456789101112#flex&#123; width: 800px; height: 400px; display: flex; background-color: blue; &#125; #flex div&#123; background-color: red; width: 100px; height: 100px; margin-right: 10px; &#125; 得到的效果如下： 明显此时每个内部元素的大小是没有100px的，将width: 100px;设置为min-width: 100px;后，得到下面的结果： 这次盒子全部溢出了。 flex-wrap定义是否允许换行。 nowrap：默认，不换行，如上面所示，如果内部的元素全部width加起来大于flex盒子的width，会将内部元素的width减小以适应flex盒子的width wrap：允许换行 wrap-reverse：换行，但是第一行变成在下方 如下面的效果： flex-flow是flex-direction和flex-wrap的简写形式 justify-content定义内部元素在主轴上的对齐方式 flex-start：跟主轴起始点对齐 flex-end：跟主轴结束点对齐 center：居中 space-between：两端对齐，内部元素之间的间隔相等 space-around：每个内部元素两侧的间隔相等 align-items定义内部元素在交叉轴上如何对齐 flex-star：跟交叉轴的起点对齐 flex-end：跟交叉轴的终点对齐 center：交叉轴的中心点对齐 baseline：内部元素的第一行文字对齐 stretch：如果内部元素没有设置高度，将占满整个容器的高度 align-content定义多根轴线的对齐方式，如果只有一个轴线，那么属性不起作用 flex-start：与交叉轴的起点对齐 flex-end：与交叉轴的终点对齐 center：与交叉轴的中点对齐 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布 space-between：每根轴线两侧的间隔相等， stretch：轴线平均分布在交叉轴上面 内部元素的属性order定义内部元素的排列顺序，默认是0，数值越小越靠前。 flex-grow定义内部元素被放大的比例，默认是0如果所有内部元素被放大的比例都是1，而且还有剩余空间的话，那么所有内部元素都会平分剩余的空间。但是如果设置放大比例后容器的width不够的话，就不会进行元素的放大，而是会将剩余的空间按照放大的倍数分配给内部元素（如果有的话） flex-shrink定义内部元素缩小的比例，如果空间不够的话，就会缩小内部元素如果有一个元素的缩小比例为0，而其他的为0以外的数字，那前者在空间不足的时候不会缩小 flex-basis定义在分配多余空间之前，内部元素的main size flexflex-grow、flex-shrink和flex-basis的简写 align-self允许单个元素与其他项目有不一样的对齐方式，可以覆盖align-item属性 auto flex-start flex-end center baseline stretch]]></content>
      <categories>
        <category>html&amp;&amp;css</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html和css知识点总结]]></title>
    <url>%2F2018%2F03%2F08%2Fhtml%E5%92%8Ccss%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[这篇文章是对HTML和CSS一些知识点的总结，希望对大家有所帮助 1 HTML1.1Doctype1、Doctype作用：声明文档类型，告知浏览器使用哪种方式对文档进行解析， HTML 4.01各种Doctype声明格式以及区别： Strict：&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;包含所有的HTML元素和属性，但是不包含过时的元素 Transitional：&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;包含所有的HTML元素和属性，同时包含过时的元素，框架集不允许 Frameset：&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Frameset//EN&quot; &quot;http://www.w3.org/TR/html4/frameset.dtd&quot;&gt;包含所有的HTML元素和属性，包含过时元素，框架集允许 HTML5Doctype的声明：&lt;!DOCTYPE HTML&gt;HTML5没有基于SGML（标准通用标记语言，超文本格式的最高标准） 1.2 MetaMeta包含在head元素中，能够对文档进行声明，比如SEO,文档的字符编码 具体作用： 声明文档使用的字符编码：&lt;meta charset=&#39;utf-8&#39;&gt; 声明文档的兼容模式： 12&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; 指示IE以目前可用的最高模式显示内容&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Emulate IE7&quot; /&gt;指示IE使用 &lt;!DOCTYPE&gt; 指令确定如何呈现内容。标准模式指令以IE7 标准模式显示，而 Quirks 模式指令以 IE5 模式显示。 SEO优化 1234&lt;meta name=&quot;description&quot; content=&quot;不超过150个字符&quot; /&gt;页面描述&lt;meta name=&quot;keywords&quot; content=&quot;关键字&quot;/&gt;页面关键词&lt;meta name=&quot;author&quot; content=&quot;魔法小栈&quot; /&gt;定义网页作者&lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot; /&gt;定义网页搜索引擎索引方式，robotterms是一组使用英文逗号「,」分割的值，通常有如下几种取值：none，noindex，nofollow，all，index和follow。 移动端添加viewport 1234567&lt;meta name =&quot;viewport&quot; content =&quot;width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&quot;&gt;经常用在响应式中:width：可视区域的宽度，device-width：设备屏幕的宽度，可以自适应多端设备initial-scale 初始缩放比例maximum-scale 最大缩放比例minimum-scale 最小缩放比例user-scalable 是否允许用户缩放(yes/no) 页面出现很多的http请求时自动转换成https： 1&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;upgrade-insecure-requests&quot; /&gt; 1.3行内元素、块级元素以及空元素的区别1、行内元素是在同一行排列直到宽度不够转入下行，块级元素默认换行排列2、行内元素没有办法设置width、height、padding和margin，块状元素可以3、vertical-align只能作用在行内元素不能作用在块级元素4、display:block：字面上将一个元素设置为块级的5、display:inline-block：字面上将一个元素设置为行内元素，但是这种行内元素能够设置width、height、margin和padding 1.4页面导入样式方式1、在head插入&lt;style&gt;&lt;/style&gt;标签2、嵌入style=&quot;&quot;3、link引入文件4、@import中引入另外一个CSS文件（存在兼容性问题，只能在IE5以上才会兼容） 1.5浏览器内核 Trident内核：IE、360 Gecko：火狐 Presto：Opera Webkit：Chrome、Safari 2 CSS2.1盒子模型W3C制定的标准的盒子模型如下图： IE早期版本的盒子模型： 二者最大的区别在于Content区域，后者的width和height都包括了padding和border 对盒子模型的设置：123box-sizing:content-box;(默认）//页面使用标准模式进行解析box-sizing:border-box;//使用怪异模式box-sizing:inherit;//页面从父元素继承box-sizing的值 2.2选择器CSS中除了平时经常用的选择器如id、类和父子选择器外，还有一些不经常用的选择器： 相邻选择器：ul+p，选择和ul同辈的后面的第一个p元素 属性选择器：li[name=&#39;bob&#39;]，选择所有name属性为bob的li元素，name属性需要自己添加 a系列的伪类选择器：a:link，a:visited，a:hover，a:acitve，分别代表未访问的链接、已经访问的链接、鼠标悬停时的链接、被点击的链接 2.3居中1、水平居中：给盒子设置一个确定的width，然后添加margin:0 auto1234#center&#123; width: 300px; margin:0 auto; &#125; 2、绝对定位的div居中123456#absolute&#123; position: absolute; width:300px; margin-left: -150px; left:50%; &#125; 3、绝对垂直居中12345678910111213141516171819202122232425262728293031323334//缺点：元素的宽高必须是具体值或者是百分比#absolute-center&#123; position: absolute; width: 100px; height:100px; top: 0; left:0; right: 0; bottom: 0; margin: auto; background-color: black; &#125; //利用translate是百分比是相对于自身的width和height #absolute-center&#123; position: absolute; width: 10%; height:10%; top: 50%; left:50%; transform: translate(-50%,-50%); &#125;//使用flex布局.container &#123; display: flex; align-items: center; /* 垂直居中 */ justify-content: center; /* 水平居中 */ &#125; .container div &#123; width: 100px; height: 100px; background-color: pink; /* 方便看效果 */ &#125; 2.4清除浮动清除浮动的原因是在使用浮动之后，元素会脱离文档流，类似于将浮动的元素抽离出来，浮动在上方，而文档在下方，分成两层。这样就会造成塌陷。最经典的例子就是在圣杯布局里面。 先看下面这圣杯布局的代码以及效果12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//html&lt;body&gt;&lt;div id=&quot;header&quot;&gt;#header&lt;/div&gt;&lt;div id=&quot;container&quot;&gt; &lt;div id=&quot;center&quot; class=&quot;column&quot;&gt;#center&lt;/div&gt; &lt;div id=&quot;left&quot; class=&quot;column&quot;&gt;#left&lt;/div&gt; &lt;div id=&quot;right&quot; class=&quot;column&quot;&gt;#right&lt;/div&gt;&lt;/div&gt;&lt;div id=&quot;footer&quot;&gt;#footer&lt;/div&gt;&lt;/body&gt;//cssbody &#123; min-width: 550px; /* 2x LC width + RC width */ &#125; #container&#123; padding-left: 200px; padding-right: 200px; background-color: red; &#125; .column&#123; float: left; height: 200px; &#125; #center&#123; width: 100%; background-color: aquamarine; &#125; #left,#right&#123; position: relative; width: 200px; &#125; #left&#123; margin-left: -100%; right: 200px; background-color: blue; &#125; #right&#123; margin-right: -200px; background-color: #00B7FF; &#125; #footer &#123; clear: both;//清除浮动 &#125; #header, #footer &#123; background-color: #c9c9c9; &#125; /*** IE6 Fix ***/ * html #left &#123; left: 150px;/* RC width */ &#125; 效果图： 此时footer是在最底下的。然后去掉这段代码：123#footer &#123; clear: both;//清除浮动 &#125; 再看效果如下： 很明显，footer跑到header下面了，很好说明了使用float后元素被抽离的本质。 那么，如何清除浮动呢？具体有以下几种方式: 父级元素设置高度以上面的圣杯布局为例，给container设置高度，然后就可以看见footer跑到下面来了，原理就是因为元素浮动后脱离文档流，在没有给父盒子设置高度的情况下，父盒子里面没有包含东西，所以默认的高度是0，设置之后就相当于给父盒子填充了内容，不过缺点是高度限制住了 使用clear:both，在浮动元素后面添加一个占位元素，然后使用clear属性。以上面的为例： 123456789101112131415//html&lt;div id=&quot;container&quot;&gt; &lt;div id=&quot;center&quot; class=&quot;column&quot;&gt;#center&lt;/div&gt; &lt;div id=&quot;left&quot; class=&quot;column&quot;&gt;#left&lt;/div&gt; &lt;div id=&quot;right&quot; class=&quot;column&quot;&gt;#right&lt;/div&gt;&lt;/div&gt;&lt;div id=&apos;clear&apos;&gt;&lt;/div&gt;//占位元素&lt;div id=&quot;footer&quot;&gt;#footer&lt;/div&gt;//css#clear&#123; height:0; clear: both; &#125; 使用伪类，原理也是使用占位元素，还是以圣杯布局为例，在父元素container使用伪类 12345#container:after&#123; content: &apos;&apos;; height:0; clear: both; &#125; ###2.5圣杯布局圣杯布局是经典的三栏布局，是前端入门必须掌握的一个布局方式，但是，网上有很多博客都有讲到如何实现圣杯布局，但是在原理上面却没有深究，其中两个关键点是左边的盒子为什么要加上margin-left: -100%;，这个属性而右边的盒子为什么要加上margin-right: -200px;（假设盒子是200px宽）这个属性。具体的如何实现圣杯布局的代码和过程可以参考这篇文章，作者讲得很详细：关于圣杯布局 下面我就来讲讲我对其中原理的理解，具体的圣杯布局的代码可以参考上面或者是推荐的文章。 因为center、left和right三者都用了float:left，所以，如果在container的width足够大的情况下，三者是如下图排列的： 所以，如果此时想让left跑到center的左边，就得用margin-left:100%，margin-left:100%百分比是相对于父元素，之后三者的排列关系如下： 此时left是覆盖在center上面的，然后再使用position:relative进行位置的调整，然后对于右边的盒子呢，不要忘记上面是我们假设父盒子width足够大的情况下，但是实际情况是父盒子设置了padding，所以实际情况下三者的位置是如下面的： 因为宽度不够，原本的left和right都被挤到下面来了，但是left在设置了margin-left转移到上面去了，right就跑到最左边来了，结合上一个图，可以知道原本上图right所在的位置是实际情况中的container的padding，那么如果想让right盒子跑到右边，那么就设置margin-right等于他自身就可以了。 2.6 SEO前端实现SEO优化的技巧：1、使用好meta标签 meta的keywords，说明网站的关键词。具体代码如下：&lt;meta name=&quot;Keywords&quot;content=&quot;信息参数&quot;/&gt; meta的description，说明网站的主要内容和概况，代码：&lt;meta name=&quot;Description&quot;content=&quot;信息参数&quot;/&gt; meta的robots，告诉搜素引擎抓取哪些页面，代码：&lt;meta name=&quot;Robots&quot; content=&quot;all&quot;/&gt;all代表文件可以被检索，同时页面上的链接可以被查询具体的Robots的参数如下： 参数 含义 all 文件可以被检索，且页面上的链接可以被查询 none 文件不被检索，页面上的链接不可以查询 index 文件被检索 follow 页面上的链接可以被查询 noindex 问价将不被检索，但页面上的链接可以被查询 nofollow 问价将被检索，页面上的链接不可以被检索 2、其他的优化SEO的技巧： 每个页面只出现一个h1 图片加alt，图片大小做声明，如果图片大小不定义的话会造成页面重新渲染，小图标使用雪碧图，如果能够使用CSS，不使用图片，减少请求次数。 尽量使用iframe框架，重要内容不要放在iframe中 尽量给a标签加上title 参考文章前端开发面试题SEO优化技巧]]></content>
      <categories>
        <category>html&amp;&amp;css</category>
      </categories>
      <tags>
        <tag>html、css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F09%2F26%2FHello-World%2F</url>
    <content type="text"><![CDATA[Hello World!]]></content>
      <tags>
        <tag>personal</tag>
      </tags>
  </entry>
</search>
