<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[异步]]></title>
    <url>%2F2018%2F03%2F15%2Fasy-md%2F</url>
    <content type="text"><![CDATA[1 同步与异步简单来说，单线程对应就是同步，同步执行中每个动作只能等前面那个执行完后才会执行下一个，这样的话如果出现多个执行动作，就会出现时间先后，有可能中间某个动作占用的时间过于长的话就会造成后面的动作一直等待。但是如果是异步呢，多个人进行组装，每个人负责不同的部分，这样的话每个人完成自己的部分之后就可以u干别的事情，而不用去一直等待，这样的效率显然是更高的。 2 Event Loop讲到JavaScript的异步的话肯定要讲到Event Loop，这是JavaScript异步的精髓。首先介绍一下一个很经典的视频（需要翻墙，国内可能也有，需要读者自己去找一下）：What the heck is the event loop anyway? 这里借用阮一峰老师的博客上面的图片： 上面这张图片展示了js代码的执行过程。最主要的三个部分就是stack、callback queue和WebAPIS 2.1 stackstack可以理解成js函数执行的地方。先看看下面这个例子： 1234567891011function fun1()&#123; console.log(&quot;this is a stack&quot;);&#125;;function fun2()&#123; fun1();&#125;;function fun3()&#123; fun2()&#125;; 上面这段代码的执行顺序是： fun3入栈 fun2入栈 fun1入栈 console.log(&quot;this is a stack&quot;) fun1出栈 fun2出栈 fun3出栈 上面这个例子很好地说明了js代码的执行机制。 而且有点需要注意的是stack里面执行的是同步函数，这一点下面会讲解 2.2 WebAPIWebAPI可以看成是临时存储异步命令的地方。 2.3 callback queuecallback queue一种更加通俗的说法是任务队列，任务队列是各种等待执行的任务，当stack处于清空状态的时候stack就会从任务队列中调用任务进行执行，而且这个过程会一直持续直到任务队列为空 2.4 Event Loop运行过程 首先执行stack里面的函数 如果在stack执行过程中有异步命令产生，就会将其传送到WebAPI中。然后按照顺序将异步命令中的回调函数加入到任务队列中，但是setTimeOut和Ajax以及setInterval会有差异，setTimeOut和setInterval会在指定时间后才将回调函数加入到任务队列中（下面有一个例子会讲到），而Ajax请求则是会在请求完成之后才将回调函数加入带任务队列中。 等到stack中的同步函数执行完毕后stack就会开始执行任务队列中的回调函数直到任务队列为空 重复执行上面这几个操作步骤 下面来看例子：12345678910111213console.log(4);setTimeout(function cb()&#123; console.log(&quot;there&quot;);&#125;,0);function fun1()&#123; console.log(&quot;this&quot;);&#125;fun1();//结果：4thisthere 上面这个例子很好地说明了任务队列里面的回调函数只有在stack里面的同步函数执行完毕之后才会开始执行。因为如果不是等待stack里面的同步函数执行完的话，那么一开始打印出来的应该是“there”而不是“this” 3 实现异步由于目前学习知识有限，我先针对自己学习的知识点讲解两种异步的实现方法 3.1 回调函数模式先看一个最简单的例子：123456789function fun3()&#123; console.log(3);&#125;;function fun2(fun)&#123; setTimeout(fun(),1000)&#125;;fun2(fun3);//3 但是这种模式只适合需要调用少量函数的情况，在某些复杂的情况下可能会出现所谓的“回调地狱”，比如下面这个例子： 123456789fun1(function()&#123; fun2(function()&#123; fun3(function()&#123; fun4(function()&#123; fun5() &#125;) &#125;) &#125;)&#125;) 3.2 Promise先看看Promise的最简单的例子123456789101112131415161718let promise = new Promise(function (resolve,reject) &#123; if (dosomething/*异步操作成功*/) &#123; resolve(); &#125;else &#123; reject(); &#125;&#125;);promise.then(fun1,fun2);//使用promise实现settimeoutlet promise = function (fun1,fun2) &#123; return new Promise(function (fun1,fun2) &#123; setTimeout(fun1,1000); &#125;);&#125;;promise().then(function () &#123; console.log(&apos;YOU&apos;);&#125;); 来看看在Node使用Promise实现文件读取的例子12345678910111213141516171819202122232425//promise实现文件读取const fs = require(&apos;fs&apos;);//使用回调函数实现fs.readFile(&apos;try.html&apos;,(err,data)=&gt;&#123; if (err) &#123; console.log(&apos;something wrong&apos;); &#125; console.log(data);&#125;);//promise化function getFile(url) &#123; return new Promise(function (resolve,reject) &#123; fs.readFile(url,function (err,data) &#123; if (err) &#123; reject(err); &#125;else &#123; resolve(data) &#125; &#125;) &#125;);&#125;getFile(&apos;try.html&apos;).then(function (data) &#123; console.log(data); &#125;).catch((err)=&gt;&#123;throw er Promise的实现异步的关键在于使用Promise封装异步操作，然后再返回一个新的Promise对象，实现链式调用。再来看看Promise是怎么解决多层调用的问题的，比如现在有三个文件要读取，但是只能在前一个文件读取完毕之后又才能进入下一个文件的读取，下面展示回调函数形式和Promise形式实现的区别123456789101112131415161718192021222324//回调函数fun1(function()&#123; fun2(function()&#123; fun3(function()&#123; fun4(function()&#123; fun5() &#125;) &#125;) &#125;)&#125;)//Promisefunction getFile(url) &#123; return new Promise(function (resolve,reject) &#123; fs.readFile(url,function (err,data) &#123; if (err) &#123; reject(err); &#125;else &#123; resolve(data) &#125; &#125;) &#125;);&#125;getFile(&apos;try.html&apos;).then(getFile(&apos;fs.js&apos;)).then(getFile(&apos;hello.txt&apos;)).then(()=&gt;&#123;console.log(&apos;success&apos;);&#125;).catch(()=&gt;&#123; throw err&#125;); 所以，使用Promise的关键点在于将原本的回调变成Promise中的resolve，然后返回一个新的Promise对象。 Promise的有趣之处还在于其提供的Promise.all()和Promise.race两个方法。 Promise.all()将多个Promise实例包装成一个新的Promise实例，接收一个数组作为参数。 只有所有的Promise实例状态变成fullfilled时，all才会变成fulfilled 只要有一个实例的状态时rejected，那么all的状态就是rejected 上面的例子其实也可以使用Promise来进行修改，如下：123456let p1 = getFile(&apos;try.html&apos;);let p2 = getfs(&apos;fs.js&apos;);let p3 = getHello(&apos;hello.txt&apos;);let p = Promise.all([p1,p2,p3]);p.then((data)=&gt;&#123;console.log(data);&#125;).catch((err)=&gt;&#123;throw err&#125;);//返回三个文件的data，存于一个数组中//这种写法的好处是可以几个异步同时进行，节省时间 Promise.race()格式和Promise.all()一样，但是不同的地方在于只要p中的一个promise的状态改变，race的状态发生改变。 3.3 Generator实现异步还是上面那个例子，使用generator+co模块实现的代码如下： 123456789101112131415161718function getFile(url) &#123; fs.readFile(url,function (err,data) &#123; return new Promise(function (resolve,reject) &#123; if (err) &#123; reject(); &#125; resolve(); &#125;); &#125;)&#125;//引入co模块辅助自动执行co(function* ()&#123; var f1 = yield readFile(&apos;fs.js&apos;); var f2 = yield readFile(&apos;try.js&apos;); console.log(f1); console.log(f2);&#125;) 3.4 async/await使用async函数实现上面的异步代码如下：123456async function getfs() &#123; let f1 = await getFile(&apos;try.html&apos;); let f2 = await getFile(&apos;fs.js&apos;); return f1;&#125;getfs().then((f1)=&gt;&#123;console.log(f1);&#125;); 需要注意的有以下几点： asyn函数返回一个Promise对象 返回的Promise对象必须等到内部所有await命令的Promise对象执行完毕后，才会发生状态的改变 await后面必须接一个Promise对象，否则其会被转化为Promise对象 只要有一个await后面的Promise变为reject，那么整个async就会中断执行 一旦遇到await，就会等到await执行完毕后再执行后面的代码。 捕获错误时，最好将await放在try...catch中 123456async function getfs() &#123; let f1=await getFile(&apos;try.html&apos;).catch((error)=&gt;&#123; throw error&#125;); let f2 = await getFile(&apos;fs.js&apos;); return f1;&#125;getfs().then((f1)=&gt;&#123;console.log(f1);&#125;); 对于不存在继发关系的多个异步操作，为节省时间最好同时触发 1let [foo, bar] = await Promise.all([getFoo(), getBar()]);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flex]]></title>
    <url>%2F2018%2F03%2F08%2Fflex%2F</url>
    <content type="text"><![CDATA[因为老是记不住flex的API对应的样式，所以这篇文章主要就是让自己平时用的时候可以快速查阅，节约时间。 flex布局是CSS3中提出的概念，其优点在于能够使用很少的样式实现比较复杂的布局，相比CSS2中的使用display+position+float的实现方式，类似于高铁和绿皮火车之间的差别。 语法块状元素实现flex布局：1div&#123;display:flex;&#125; 行内元素实现flex布局：1div&#123;display:inline-flex;&#125; 基本概念容器flex化之后，其内部解构如下（这里借用一下阮老师的图）： flex item：容器内部的元素main axis：主轴，内部元素默认沿着主轴排列main start：主轴开始的地方main end：主轴结束的地方cross axis：交叉轴cross start：交叉轴开始的地方cross end：交叉轴结束的地方main size：单个内部元素在主轴方向上占据的长度cross size：单个内部元素在交叉轴方向上占据的长度 属性及其值 flex-direction:row | row-reverse | column | column-reverse flex-wrap:nowrap | wrap | wrap-reverse flex-flow:&lt;flex-direction | &lt;flex-wrap&gt; justify-content:flex-start | flex-end | cneter | space-between | space-around align-items: flex-start | flex-end | center | baseline | stretch align-content: flex-start | flex-end | center | space-between | space-around | stretch; flex-direction定义主轴的方向 row：默认，主轴的方向为水平，起点在左端 row-reverse：主轴为水平，起点在右端 column：主轴为竖直方向，起点在顶端 column-reverse：主轴为竖直方向，起点在底端 对flex盒子的内部元素进行width的设置时，实际上相当于是给元素设置了一个max-width，如下面例子：123456789101112#flex&#123; width: 800px; height: 400px; display: flex; background-color: blue; &#125; #flex div&#123; background-color: red; width: 100px; height: 100px; margin-right: 10px; &#125; 得到的效果如下： 明显此时每个内部元素的大小是没有100px的，将width: 100px;设置为min-width: 100px;后，得到下面的结果： 这次盒子全部溢出了。 flex-wrap定义是否允许换行。 nowrap：默认，不换行，如上面所示，如果内部的元素全部width加起来大于flex盒子的width，会将内部元素的width减小以适应flex盒子的width wrap：允许换行 wrap-reverse：换行，但是第一行变成在下方 如下面的效果： flex-flow是flex-direction和flex-wrap的简写形式 justify-content定义内部元素在主轴上的对齐方式 flex-start：跟主轴起始点对齐 flex-end：跟主轴结束点对齐 center：居中 space-between：两端对齐，内部元素之间的间隔相等 space-around：每个内部元素两侧的间隔相等 align-items定义内部元素在交叉轴上如何对齐 flex-star：跟交叉轴的起点对齐 flex-end：跟交叉轴的终点对齐 center：交叉轴的中心点对齐 baseline：内部元素的第一行文字对齐 stretch：如果内部元素没有设置高度，将占满整个容器的高度 align-content定义多根轴线的对齐方式，如果只有一个轴线，那么属性不起作用 flex-start：与交叉轴的起点对齐 flex-end：与交叉轴的终点对齐 center：与交叉轴的中点对齐 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布 space-between：每根轴线两侧的间隔相等， stretch：轴线平均分布在交叉轴上面 内部元素的属性order定义内部元素的排列顺序，默认是0，数值越小越靠前。 flex-grow定义内部元素被放大的比例，默认是0如果所有内部元素被放大的比例都是1，而且还有剩余空间的话，那么所有内部元素都会平分剩余的空间。但是如果设置放大比例后容器的width不够的话，就不会进行元素的放大，而是会将剩余的空间按照放大的倍数分配给内部元素（如果有的话） flex-shrink定义内部元素缩小的比例，如果空间不够的话，就会缩小内部元素如果有一个元素的缩小比例为0，而其他的为0以外的数字，那前者在空间不足的时候不会缩小 flex-basis定义在分配多余空间之前，内部元素的main size flexflex-grow、flex-shrink和flex-basis的简写 align-self允许单个元素与其他项目有不一样的对齐方式，可以覆盖align-item属性 auto flex-start flex-end center baseline stretch]]></content>
      <categories>
        <category>html&amp;&amp;css</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html和css知识点总结]]></title>
    <url>%2F2018%2F03%2F08%2Fhtml%E5%92%8Ccss%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[这篇文章是对HTML和CSS一些知识点的总结，希望对大家有所帮助 1 HTML1.1Doctype1、Doctype作用：声明文档类型，告知浏览器使用哪种方式对文档进行解析， HTML 4.01各种Doctype声明格式以及区别： Strict：&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;包含所有的HTML元素和属性，但是不包含过时的元素 Transitional：&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;包含所有的HTML元素和属性，同时包含过时的元素，框架集不允许 Frameset：&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Frameset//EN&quot; &quot;http://www.w3.org/TR/html4/frameset.dtd&quot;&gt;包含所有的HTML元素和属性，包含过时元素，框架集允许 HTML5Doctype的声明：&lt;!DOCTYPE HTML&gt;HTML5没有基于SGML（标准通用标记语言，超文本格式的最高标准） 1.2 MetaMeta包含在head元素中，能够对文档进行声明，比如SEO,文档的字符编码 具体作用： 声明文档使用的字符编码：&lt;meta charset=&#39;utf-8&#39;&gt; 声明文档的兼容模式： 12&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; 指示IE以目前可用的最高模式显示内容&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Emulate IE7&quot; /&gt;指示IE使用 &lt;!DOCTYPE&gt; 指令确定如何呈现内容。标准模式指令以IE7 标准模式显示，而 Quirks 模式指令以 IE5 模式显示。 SEO优化 1234&lt;meta name=&quot;description&quot; content=&quot;不超过150个字符&quot; /&gt;页面描述&lt;meta name=&quot;keywords&quot; content=&quot;关键字&quot;/&gt;页面关键词&lt;meta name=&quot;author&quot; content=&quot;魔法小栈&quot; /&gt;定义网页作者&lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot; /&gt;定义网页搜索引擎索引方式，robotterms是一组使用英文逗号「,」分割的值，通常有如下几种取值：none，noindex，nofollow，all，index和follow。 移动端添加viewport 1234567&lt;meta name =&quot;viewport&quot; content =&quot;width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&quot;&gt;经常用在响应式中:width：可视区域的宽度，device-width：设备屏幕的宽度，可以自适应多端设备initial-scale 初始缩放比例maximum-scale 最大缩放比例minimum-scale 最小缩放比例user-scalable 是否允许用户缩放(yes/no) 页面出现很多的http请求时自动转换成https： 1&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;upgrade-insecure-requests&quot; /&gt; 1.3行内元素、块级元素以及空元素的区别1、行内元素是在同一行排列直到宽度不够转入下行，块级元素默认换行排列2、行内元素没有办法设置width、height、padding和margin，块状元素可以3、vertical-align只能作用在行内元素不能作用在块级元素4、display:block：字面上将一个元素设置为块级的5、display:inline-block：字面上将一个元素设置为行内元素，但是这种行内元素能够设置width、height、margin和padding 1.4页面导入样式方式1、在head插入&lt;style&gt;&lt;/style&gt;标签2、嵌入style=&quot;&quot;3、link引入文件4、@import中引入另外一个CSS文件（存在兼容性问题，只能在IE5以上才会兼容） 1.5浏览器内核 Trident内核：IE、360 Gecko：火狐 Presto：Opera Webkit：Chrome、Safari 2 CSS2.1盒子模型W3C制定的标准的盒子模型如下图： IE早期版本的盒子模型： 二者最大的区别在于Content区域，后者的width和height都包括了padding和border 对盒子模型的设置：123box-sizing:content-box;(默认）//页面使用标准模式进行解析box-sizing:border-box;//使用怪异模式box-sizing:inherit;//页面从父元素继承box-sizing的值 2.2选择器CSS中除了平时经常用的选择器如id、类和父子选择器外，还有一些不经常用的选择器： 相邻选择器：ul+p，选择和ul同辈的后面的第一个p元素 属性选择器：li[name=&#39;bob&#39;]，选择所有name属性为bob的li元素，name属性需要自己添加 a系列的伪类选择器：a:link，a:visited，a:hover，a:acitve，分别代表未访问的链接、已经访问的链接、鼠标悬停时的链接、被点击的链接 2.3居中1、水平居中：给盒子设置一个确定的width，然后添加margin:0 auto1234#center&#123; width: 300px; margin:0 auto; &#125; 2、绝对定位的div居中123456#absolute&#123; position: absolute; width:300px; margin-left: -150px; left:50%; &#125; 3、绝对垂直居中12345678910111213141516171819202122232425262728293031323334//缺点：元素的宽高必须是具体值或者是百分比#absolute-center&#123; position: absolute; width: 100px; height:100px; top: 0; left:0; right: 0; bottom: 0; margin: auto; background-color: black; &#125; //利用translate是百分比是相对于自身的width和height #absolute-center&#123; position: absolute; width: 10%; height:10%; top: 50%; left:50%; transform: translate(-50%,-50%); &#125;//使用flex布局.container &#123; display: flex; align-items: center; /* 垂直居中 */ justify-content: center; /* 水平居中 */ &#125; .container div &#123; width: 100px; height: 100px; background-color: pink; /* 方便看效果 */ &#125; 2.4清除浮动清除浮动的原因是在使用浮动之后，元素会脱离文档流，类似于将浮动的元素抽离出来，浮动在上方，而文档在下方，分成两层。这样就会造成塌陷。最经典的例子就是在圣杯布局里面。 先看下面这圣杯布局的代码以及效果12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//html&lt;body&gt;&lt;div id=&quot;header&quot;&gt;#header&lt;/div&gt;&lt;div id=&quot;container&quot;&gt; &lt;div id=&quot;center&quot; class=&quot;column&quot;&gt;#center&lt;/div&gt; &lt;div id=&quot;left&quot; class=&quot;column&quot;&gt;#left&lt;/div&gt; &lt;div id=&quot;right&quot; class=&quot;column&quot;&gt;#right&lt;/div&gt;&lt;/div&gt;&lt;div id=&quot;footer&quot;&gt;#footer&lt;/div&gt;&lt;/body&gt;//cssbody &#123; min-width: 550px; /* 2x LC width + RC width */ &#125; #container&#123; padding-left: 200px; padding-right: 200px; background-color: red; &#125; .column&#123; float: left; height: 200px; &#125; #center&#123; width: 100%; background-color: aquamarine; &#125; #left,#right&#123; position: relative; width: 200px; &#125; #left&#123; margin-left: -100%; right: 200px; background-color: blue; &#125; #right&#123; margin-right: -200px; background-color: #00B7FF; &#125; #footer &#123; clear: both;//清除浮动 &#125; #header, #footer &#123; background-color: #c9c9c9; &#125; /*** IE6 Fix ***/ * html #left &#123; left: 150px;/* RC width */ &#125; 效果图： 此时footer是在最底下的。然后去掉这段代码：123#footer &#123; clear: both;//清除浮动 &#125; 再看效果如下： 很明显，footer跑到header下面了，很好说明了使用float后元素被抽离的本质。 那么，如何清除浮动呢？具体有以下几种方式: 父级元素设置高度以上面的圣杯布局为例，给container设置高度，然后就可以看见footer跑到下面来了，原理就是因为元素浮动后脱离文档流，在没有给父盒子设置高度的情况下，父盒子里面没有包含东西，所以默认的高度是0，设置之后就相当于给父盒子填充了内容，不过缺点是高度限制住了 使用clear:both，在浮动元素后面添加一个占位元素，然后使用clear属性。以上面的为例： 123456789101112131415//html&lt;div id=&quot;container&quot;&gt; &lt;div id=&quot;center&quot; class=&quot;column&quot;&gt;#center&lt;/div&gt; &lt;div id=&quot;left&quot; class=&quot;column&quot;&gt;#left&lt;/div&gt; &lt;div id=&quot;right&quot; class=&quot;column&quot;&gt;#right&lt;/div&gt;&lt;/div&gt;&lt;div id=&apos;clear&apos;&gt;&lt;/div&gt;//占位元素&lt;div id=&quot;footer&quot;&gt;#footer&lt;/div&gt;//css#clear&#123; height:0; clear: both; &#125; 使用伪类，原理也是使用占位元素，还是以圣杯布局为例，在父元素container使用伪类 12345#container:after&#123; content: &apos;&apos;; height:0; clear: both; &#125; ###2.5圣杯布局圣杯布局是经典的三栏布局，是前端入门必须掌握的一个布局方式，但是，网上有很多博客都有讲到如何实现圣杯布局，但是在原理上面却没有深究，其中两个关键点是左边的盒子为什么要加上margin-left: -100%;，这个属性而右边的盒子为什么要加上margin-right: -200px;（假设盒子是200px宽）这个属性。具体的如何实现圣杯布局的代码和过程可以参考这篇文章，作者讲得很详细：关于圣杯布局 下面我就来讲讲我对其中原理的理解，具体的圣杯布局的代码可以参考上面或者是推荐的文章。 因为center、left和right三者都用了float:left，所以，如果在container的width足够大的情况下，三者是如下图排列的： 所以，如果此时想让left跑到center的左边，就得用margin-left:100%，margin-left:100%百分比是相对于父元素，之后三者的排列关系如下： 此时left是覆盖在center上面的，然后再使用position:relative进行位置的调整，然后对于右边的盒子呢，不要忘记上面是我们假设父盒子width足够大的情况下，但是实际情况是父盒子设置了padding，所以实际情况下三者的位置是如下面的： 因为宽度不够，原本的left和right都被挤到下面来了，但是left在设置了margin-left转移到上面去了，right就跑到最左边来了，结合上一个图，可以知道原本上图right所在的位置是实际情况中的container的padding，那么如果想让right盒子跑到右边，那么就设置margin-right等于他自身就可以了。 2.6 SEO前端实现SEO优化的技巧：1、使用好meta标签 meta的keywords，说明网站的关键词。具体代码如下：&lt;meta name=&quot;Keywords&quot;content=&quot;信息参数&quot;/&gt; meta的description，说明网站的主要内容和概况，代码：&lt;meta name=&quot;Description&quot;content=&quot;信息参数&quot;/&gt; meta的robots，告诉搜素引擎抓取哪些页面，代码：&lt;meta name=&quot;Robots&quot; content=&quot;all&quot;/&gt;all代表文件可以被检索，同时页面上的链接可以被查询具体的Robots的参数如下： 参数 含义 all 文件可以被检索，且页面上的链接可以被查询 none 文件不被检索，页面上的链接不可以查询 index 文件被检索 follow 页面上的链接可以被查询 noindex 问价将不被检索，但页面上的链接可以被查询 nofollow 问价将被检索，页面上的链接不可以被检索 2、其他的优化SEO的技巧： 每个页面只出现一个h1 图片加alt，图片大小做声明，如果图片大小不定义的话会造成页面重新渲染，小图标使用雪碧图，如果能够使用CSS，不使用图片，减少请求次数。 尽量使用iframe框架，重要内容不要放在iframe中 尽量给a标签加上title 参考文章前端开发面试题SEO优化技巧]]></content>
      <categories>
        <category>html&amp;&amp;css</category>
      </categories>
      <tags>
        <tag>html、css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F09%2F26%2FHello-World%2F</url>
    <content type="text"><![CDATA[Hello World!]]></content>
      <tags>
        <tag>personal</tag>
      </tags>
  </entry>
</search>
